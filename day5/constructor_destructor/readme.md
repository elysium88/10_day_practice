###一、类对象成员的构造
先构造成员
再构造自身（调用构造函数）
###二、派生类构造函数
派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要调用基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。

**派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数**，形式如下：

派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…{
//……
}

###三、构造函数和析构函数调用次序
**派生类对象的构造**

- 先构造基类
- 再构造成员
- 最后构造自身（调用构造函数）

基类构造顺序由派生层次决定：**最远的基类最先构造**
成员构造顺序和定义顺序符合
析构函数的析构顺序与构造相反

###四、构造函数和析构函数的构造规则

- 1.派生类可以不定义构造函数的情况 当具有下述情况之一时，派生类可以不定义构造函数。 基类没有定义任何构造函数。 基类具有缺省参数的构造函数。 基类具有无参构造函数。 
- 2.派生类必须定义构造函数的情况 当基类或成员对象所属类只含有带参数的构造函数时，即使派生类本身没有数据成员要初始化，它也必须定义构造函数，并以构造函数初始化列表的方式向基类和成员对象的构造函数传递参数，以实现基类子对象和成员对象的初始化。 
- 3.派生类的构造函数只负责直接基类的初始化

C++语言标准有一条规则：如果派生类的基类同时也是另外一个类的派生类，则每个派生类只负责它的直接基类的构造函数调用。 
这条规则表明当派生类的直接基类只有带参数的构造函数，但没有默认构造函数时（包括缺省参数和无参构造函数），
它必须在构造函数的初始化列表中调用其直接基类的构造函数，并向基类的构造函数传递参数，以实现派生类对象中的基类子对象的初始化。 
这条规则有一个例外情况，当派生类存在虚基类时，所有虚基类都由最后的派生类负责初始化。


总结： 
- 1.当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先调用基类B的构造函数，再调用基类A的构造函数。

- 2.当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。

- 3.当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码。